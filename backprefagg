
class ComboPref(object):
    '''Used when there are discrete values prefs can take
    If a value can be another Pref, which can hold more prefs
    '''
    def __init__(self, sel, vals):
        self.sel = sel
        self.vals = vals
    def __call__(self):
        return self.vals[self.sel]
    def __str__(self):
        return str(self.vals[self.sel])

class Pref(DynStruct):
    '''
    Structure for Creating Preferences. 
    Caveats: 
        When using a value call with ['valname'] to be safe
    Features: 
      * Can be saved and loaded.
      * Can be nested 
      * Dynamically add/remove
    '''
    def __init__(self,\
                 default=None,\
                 doc='',\
                 min=None,\
                 max=None,\
                 choices=None,\
                 depeq=None,\
                 pref_name=None,\
                 fpath=None,\
                 copy_dict=None,\
                 parent=None):
        '''Creates a pref struct that will save itself to pref_fpath if
        available and have initail members of some dictionary'''
        super(Pref, self).__init__(child_exclude_list=\
                                   ['_intern'], copy_dict=copy_dict)
        self._intern = DynStruct()
        self._intern.fpath  = fpath # Where to save the pref
        self._intern.choices = choices
        self._tree.parent  = parent
        self._intern.child_list = []
        self._intern.child_names = []
        self._intern.pref_name  = pref_name
        self._intern.pref_value = default

    def __getattr__(self, name):
        attr = super(DynStruct, self).__getattr__(name, value)
        if type(attr) == Pref:
            if not attr._intern.pref_value is None:
                if not attr._intern.choices is None:
                    return attr._interanls.choices[ attr._intern.pref_value ]
                return attr._intern.pref_value
            else:
                return attr
        return attr

    def value(self):
        if self._intern.choices != None:
            return self._intern.choices[self._intern.pref_value] #TODO AS REFERENCE
        else:
            return self._intern.pref_value #TODO AS REFERENCE

    def __setattr__(self, name, attr):
        if len(name) > 0 and name[0] == '_':
            # Default behavior for _printable_exclude and _intern
            return super(DynStruct, self).__setattr__(name, attr)
        elif type(attr) == Pref:
            print "Setting: %r" % name
            if name in self._intern.child_names:
                raise NotImplementedError('can redefine prefs yet')
            if attr._intern.pref_name == None: # Give Child Name
                attr._intern.pref_name = name
            if attr._tree.parent == None:    # Give Child Parent
                attr._tree.parent = self
            self._intern.child_names.append(name)
            self._intern.child_list.append(attr)
            self.__dict__[name] = attr.value() #TODO AS REFERENCE
        else:
            if name in self._intern.child_names:
                print "ReSetting Non Pref Attribute: %r %r" % (name, attr)
                row = self._intern.child_names.index(name)
                old_attr = self._intern.child_list[row]
                if self._intern.choices != None:
                    if attr in old_attr._intern.choices:
                        new_sel = old_attr._intern.choices.index(attr)
                        old_attr._intern.pref_value = new_sel
                    elif type(attr) == types.IntType and attr < len(old_attr._intern.choices) and attr >= 0:
                        old_attr._intern.pref_value = attr
                    else:
                        raise Exception('The available choices are: '+str(old_attr._intern.choices))
                else:
                    self.old_attr.pref_value = attr
                    self.__dict__[name] = self.old_attr.value() #TODO AS REFERENCE
            else: 
                print "Setting Non Pref Attribute: %r %r" % (name, attr)
                pref_attr = Pref(default=attr)
                self.__setattr__(name, pref_attr)

    def call(self):
        return self.value()

    def rebuild_tree_structure(self):
        'Add all children of any Pref'
        self._intern.child_list = []
        if type(self.pref_value) == Pref:
            for (key, val) in self.pref_value.iteritems():
                self._intern.child_list.append(Pref(pref_name=key, default=val, parent=self))

    def setParent(self, parent):
        if type(parent) != Pref:
            raise Exception('The parent of a Pref must be a Pref')
        self._inter.parent = parent

    def iteritems(self):
        for (key, val) in self.__dict__.iteritems():
            if key in self._printable_exclude: 
                continue
            yield (key, val)

    def num_items(self):
        count = -1
        for count, item in enumerate(self.iteritems()):
            pass
        return count+1

    def to_dict(self, split_structs_bit=False):
        '''Converts prefeters to a dictionary. 
        Children Pref can be optionally separated'''
        pref_dict = {}
        struct_dict = {}
        for (key, val) in self.iteritems():
            if split_structs_bit and isinstance(val, Pref):
                struct_dict[key] = val
                continue
            pref_dict[key] = val
        if split_structs_bit:
            return (pref_dict, struct_dict)
        return pref_dict

    #def __getitem__(self, key):
        #val = super(Pref, self).__getitem__(key)
        #if isinstance(val, list):
            #raise NotImplementedError
        #if isinstance(val, ComboPref):
            #return val()
        #return val

    @func_log
    def save(self):
        'Saves prefeters to disk in the form of a dict'
        if self._intern.fpath is None: 
            if self._internal.parent != None:
                logdbg('Can my parent save me?')
                return self._internal.parent.save()
            logdbg('I cannot be saved. I have no parents.')
            return False
        with open(self._intern.fpath, 'w') as f:
            logdbg('Saving to '+self._intern.fpath)
            pref_dict = self.to_dict()
            cPickle.dump(pref_dict, f)
        return True

    @func_log
    def load(self):
        'Read pref dict stored on disk. Overwriting current values.'
        if not os.path.exists(self._intern.fpath):
            return False
        with open(self._intern.fpath, 'r') as f:
            try:
                pref_dict = cPickle.load(f)
            except EOFError:
                import warnings
                warnings.warn('Preference file did not load correctly')
                return False
        if type(pref_dict) != types.DictType:
            raise Exception('Preference file is corrupted')
        self.add_dict(pref_dict)
        return True

    def toggle(self, key):
        'Toggles a boolean key'
        if not self[key] in [True, False]:
            raise Exception('Cannot toggle the non-boolean type: '+str(key))
        self.update(key, not self[key])

    @func_log
    def update(self, key, new_val):
        'Changes a prefeters value and saves it to disk'
        logdbg('Updating Preference: %s to %r' % (key, str(new_val)))
        self[key] = new_val
        return self.save()
       

    def createQPreferenceModel(self):
        'Creates a QStandardItemModel that you can connect to a QTreeView'
        return QPreferenceModel(self)

    # QT THINGS
    def data(self, column):
        if column == 0:
            return self.pref_name
        assert column == 1, 'Cant have more than 2 columns right now'
        if type(self.pref_value) == Pref: # Recursive Case: Pref
            return ''
        data = self.getPref()
        ## Base Case: Column Item
        if type(data) in [types.IntType, types.StringType, types.FloatType]:
            return data
        elif type(data) == types.BooleanType:
            return data
        elif type(data) == ComboPref:
            return data() #Calling data gives you the string value of ComboPref

    def childNumber(self):
        if self._internal.parent != None:
            return self._internal.parent.child_list.index(self)
        return 0

    def isEditable(self):
        uneditable_hack = ['database_dpath', 'use_thumbnails', 'thumbnail_size', 'kpts_extractor', 'quantizer', 'indexer']
        if self.pref_name in uneditable_hack:
            return False
        return self._internal.parent != None and type(self.pref_value) != Pref

    def getPref(self):
        'access the actual backend data'
        if self._internal.parent != None:
            # Your parent better be a Pref
            parent_prefs = self._internal.parent.pref_value
            return parent_prefs[self.pref_name]

    @func_log
    def setPref(self, qvar):
        'sets the actual backend data'
