# TODO: Let pyinstaller take care of this

#os.chdir(hotspotter_root)
#import hotspotter.tpl.cv2 as cv2 
import os, sys
from hotspotter.helpers import check_path, ensure_path, vd, copy_all, copy
from os.path import join
import types
import textwrap


# A script for windows to install pkg config (needed for building with opencv I think)
def fix_mingw_pkgconfig():
    fix_mingw_pkgconfig_bat = textwrap.dendent(r''':: autogenerated in build_tpl.py
    set pkgconfig_name=pkg-config-lite-0.28-1
    set pkgconfig_zip=%pkgconfig_name%-win32.zip
    set MINGW_BIN="C:\MinGW\bin"
    set MINGW_SHARE="C:\MinGW\bin"
    set pkg_config_dlsrc=^
    http://downloads.sourceforge.net/project/pkgconfiglite/0.28-1/%pkgconfig_name%_bin-win32.zip

    :: Download pkg-config-lite
    wget %pkg_config_dlsrc%

    :: Unzip and remove zipfile
    unzip %pkgconfig_zip%
    rm %pkgconfig_zip%

    :: Install contents to MSYS
    cp %pkgconfig_name%/bin/pkg-config.exe %MINGW_BIN%
    cp -r %pkgconfig_name%/share/aclocal %MINGW_SHARE%
    ''')
    os.system(fix_mingw_pkgconfig_bat)

__HOME__ = os.path.expanduser("~")
__CODE__ = os.path.expanduser("~")+'/code'

hotspotter_root = __CODE__+'/hotspotter'
tpl_root = hotspotter_root+'/hotspotter/tpl'

lib_exts = ['*.dll', '*.a']
pylib_exts = ['*.pyd']

if sys.platform == 'win32':
    cmake_cmd = 'cmake -G "MSYS Makefiles" '
else:
    cmake_cmd = 'cmake -G "Unix Makefiles" '

import platform
print('Platform architecture: ')
print(platform.architecture())

import struct
print('bits per instruction: '+ str(8 * struct.calcsize("P")))

import sys
print('Int Maxsize: '+str(sys.maxsize))
print('2^32 =       '+str( 2**32))
print('2^64 =       '+str( 2**64))

install_prefix   = '/usr/local/'
py_dist_packages = install_prefix+'/lib/python2.7/dist-packages'

if sys.platform == 'win32':
   #install_prefix   = 'C:/Program Files (x86)'
    #print('Progam Files (x86)? : '+str('PROGRAMFILES(X86)' in os.environ))
    #for key, val in os.environ.iteritems():
        #print(key+' = '+str(val))
    install_prefix   = os.environ['PROGRAMFILES']
    py_dist_packages = 'C:/Python27/Lib/site-packages'

def __cmd(cmd, *args):
    if 'print' in args: 
        print('...Running command: '+cmd)
    ret = os.system(cmd)
    if 'print' in args: 
        print('...In reference to command: '+str(cmd))
        print('...Return code: '+str(ret))
    if 'raise' in args:
        if ret != 0: 
            print('...ERROR!')
            ex_msg = '...In reference to command: '+cmd+\
                '\n...Return code: '+str(ret)
            raise Exception(ex_msg)
        else:
            print('...SUCCESS!')
    return ret

def __sudo_cmd(cmd, *args):
    if sys.platform == 'win32':
        ret = __cmd(cmd, *args)
    else:
        ret = __cmd('sudo '+cmd, *args)
    return ret

# Header print
#def hprint(msg, lvl=0, topline='='):
    #print('\n\n'+'='*len(init_str))

def cmake_flags2str(cmake_flags):
    'Turns a dict into a cmake arguments'
    cmake_arg_str = ''
    for key, val in cmake_flags.iteritems():
        if val == True:
            val = 'ON'
        if val == False:
            val = 'OFF'
        cmake_arg_str+='-D'+key+'='+val+' '
    return cmake_arg_str

def cd(dir):
    print('Changing directory to '+dir)
    os.chdir(dir)

def __build(pkg_name,
            branchname='hotspotter_branch',
            cmake_flags={},
            noinstall=False,
            rm_build=False):
    ''' 
    Generic build function for hotspotter third party libraries: 
        All libraries should be hosted under github.com:Erotemic/<pkg_name>
    '''
    from hs_setup.git_helpers import git_branch, git_version, git_fetch_url
    cmd_args = ['raise', 'print']
    # ---- INIT ---- #
    init_str = '_____ Python is building: '+ pkg_name +' _____'
    print('\n\n'+'='*len(init_str))
    print(init_str)
    code_src = __CODE__+'/'+pkg_name
    code_build = code_src+'/build'
    # ---- CHECK SOURCE ---- #
    print('\n --- Checking code source dir: '+code_src+'\n')
    if not check_path(code_src): 
        if not check_path(__CODE__):
            raise Exception('We have problems')
        cd(__CODE__)
        __cmd('git clone git@github.com:Erotemic/'+pkg_name+'.git', *cmd_args)
    cd(code_src)
    # ---- CHECK GIT ---- #
    print('\n --- Checking git info')
    current_branch = git_branch()
    fetch_url = git_fetch_url()
    version = git_version()
    print('   * fetch_url='+str(fetch_url))
    print('   * branch='+str(current_branch))
    #print('  * version='+str(version))
    if current_branch != branchname:
        __cmd('git checkout '+branchname, *cmd_args)
    # ---- CHECK BUILD ---- #
    if rm_build:
        print('\n --- Forcing rm build dir: ' + code_build + '\n')
        if check_path(code_build):
            __cmd('rm -rf '+code_build)
    print('\n --- Creating build dir: ' + code_build + '\n')
    ensure_path(code_build)
    cd(code_build)
    # ---- CMAKE ---- #
    print('\n --- Running cmake\n')
    if not 'CMAKE_INSTALL_PREFIX' in cmake_flags: 
        _cm_install_prefix = install_prefix
        if sys.platform == 'win32':
            _cm_install_prefix += '/' + pkg_name
        cmake_flags['CMAKE_INSTALL_PREFIX'] = _cm_install_prefix
        #raise Exception('Unexpected behavior may be occuring. Overwriting CMAKE_INSTALL_PREFIX')
    _cmake_args = cmake_flags2str(cmake_flags).replace('\n',' ')
    __cmd(cmake_cmd + _cmake_args + ' ..', *cmd_args)
    # ---- MAKE ---- #
    print('\n --- Running make\n') 
   #__cmd('make ', *cmd_args)
    __cmd('make -j9', *cmd_args)
    # ---- INSTALL ---- #
    if noinstall:
        print('\n --- Not Installing\n')
    else:
        print('\n --- Installing to: '+cmake_flags['CMAKE_INSTALL_PREFIX']+'\n')
        __sudo_cmd('make install', *cmd_args)
    # ---- END ---- #
    cd(hotspotter_root)
    exit_msg =  ' --- Finished building: '+pkg_name
    print('\n'+exit_msg)
    print('='*len(exit_msg)+'\n')

def build_hesaff():
    cmake_flags = {}
    if sys.platform == 'win32':
        cmake_flags['CMAKE_C_FLAGS']   = '-march=i486'
        cmake_flags['CMAKE_CXX_FLAGS'] = '-march=i486'
    __build('hesaff',
            branchname='hotspotter_branch',
            cmake_flags=cmake_flags,
            noinstall=True,
            rm_build=True)

def build_opencv():
    cmake_flags = {
        'BUILD_opencv_gpu'           : False,
        'BUILD_opencv_gpuarithm'     : False,
        'BUILD_opencv_gpubgsegm'     : False,
        'BUILD_opencv_gpucodec'      : False,
        'BUILD_opencv_gpufeatures2d' : False,
        'BUILD_opencv_gpufilters'    : False,
        'BUILD_opencv_gpuimgproc'    : False,
        'BUILD_opencv_gpuoptflow'    : False,
        'BUILD_opencv_gpustereo'     : False,
        'BUILD_opencv_gpuwarping'    : False }
    if sys.platform == 'win32':
        win32_flags = {
            'CMAKE_INSTALL_PREFIX'       : install_prefix+'/OpenCV',
            'CMAKE_BUILD_TYPE'           : 'Release',
            'CMAKE_C_FLAGS'              : '-m32',
            'CMAKE_CXX_FLAGS'            : '-m32' }
        cmake_flags.update(win32_flags)
    __build('opencv', cmake_flags=cmake_flags, branchname='freak_modifications')

def build_flann():
    cmake_flags = { 
        'BUILD_MATLAB_BINDINGS' : False }
    if sys.platform == 'win32':
        win32_flags = {
            'CMAKE_INSTALL_PREFIX' : install_prefix+'/Flann',
            'CMAKE_BUILD_TYPE'     : 'Release',
            'CMAKE_C_FLAGS'        : '-m32',
            'CMAKE_CXX_FLAGS'      : '-m32',
            'USE_OPENMP'           : False,
            'HDF5_INCLUDE_DIRS'    : '',
            'HDF5_ROOT_DIR'        : '' }
        cmake_flags.update_win32_flags
    __build('flann', cmake_flags=cmake_flags, branchname='hotspotter_flann')
    
def localize_hesaff():
    print('____ Localizing hessaff ____')
    hesaff_build = __CODE__+'/hesaff/build'
    check_path(hesaff_build)
    tpl_hesaff = tpl_root + '/hesaff'
    ensure_path(tpl_hesaff) 
    copy_all(hesaff_build, tpl_hesaff, 'hesaff*')
    os.system('chmod +x '+tpl_hesaff)
    with open(tpl_hesaff+'/__init__.py', 'w') as cv2_init:
        cv2_init.write(textwrap.dedent(r'''
        # autogenerated in build_tpl.py
        import os, sys
        from os.path import realpath, dirname
        tpl_cv2 = realpath(dirname(__file__)+'../cv2')
        sys.path.insert(0, tpl_cv2)
        os.environ['PATH'] = tpl_cv2 + os.pathsep + os.environ['PATH']

        import subprocess
        import numpy as np
        import os
        from os.path import dirname, realpath, join
        hesaff_exe = join(realpath(dirname(__file__)), 'hesaff')

        def compute_hesaff(rchip_fpath, chiprep_fpath):
            'Runs external keypoint detetectors like hesaff'
            outname = rchip_fpath + '.hesaff.sift'
            args = '"' + rchip_fpath + '"'
            cmd  = hesaff_exe + ' ' + args
            proc = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            (out, err) = proc.communicate()
            if proc.returncode != 0:
                raise Exception('  * Failed to execute '+cmd+'\n  * OUTPUT: '+out)
            if not os.path.exists(outname):
                raise Exception('  * The output file doesnt exist: '+outname)
            kpts, fdsc = read_text_chiprep_file(outname)
            np.savez(chiprep_fpath, kpts, fdsc)
            return kpts, fdsc

        def read_oriented_chip(chip_fpath, orientation):
            'Reads and rotates a chip'
            return chip_orient

        def normalize(array, dim=0):
            'normalizes a numpy array from 0 to 1'
            array_max  = array.max(dim)
            array_min  = array.min(dim)
            array_exnt = np.subtract(array_max, array_min)
            return np.divide(np.subtract(array, array_min), array_exnt)

        def compute_chiprep(chip_fpath, chiprep_fpath, detector, extractor, orientation, gravity, params_dict):
            'A workfunction which computes keypoints and descriptors'
            if detector == 'heshesaff':
                return compute_chiprep_external(chip_fpath, chiprep_fpath, extractor, orientation)
            return kpts, fdsc

        def read_text_chiprep_file(outname):
            'Reads output from external keypoint detectors like hesaff'
            with open(outname, 'r') as file:
                # Read header
                ndims = int(file.readline())
                nkpts = int(file.readline())
                # Preallocate output
                kpts = np.zeros((nkpts, 5), dtype=np.float32)
                fdsc = np.zeros((nkpts, ndims), dtype=np.uint8)
                # iterate over lines
                lines = file.readlines()
                for kx, line in enumerate(lines):
                    data = line.split(' ')
                    kpts[kx,:] = np.array([np.float32(_)\
                                        for _ in data[0:5]], dtype=np.float32)
                    fdsc[kx,:] = np.array([np.uint8(_)\
                                        for _ in data[5: ]], dtype=np.uint8)
                return (kpts, fdsc)
                hessaff_exe = realpath(dirname(__file__)+'/hessaff')
        '''))

def localize_opencv():
    print('____ Localizing opencv ____')
    # Where to install
    tpl_cv2 = tpl_root + '/cv2'
    ensure_path(tpl_cv2) 
    # Libraries
    opencv_lib = install_prefix+'/lib'
    if sys.platform == 'win32':
        # The opencv libraries are in bin not lib on windows. x.x
        opencv_lib = install_prefix+'/OpenCV/bin'
        # Move the MinGW libs too
        mingw_lib = 'C:/MinGW/bin'
        copy_all(mingw_lib, tpl_cv2, ['libgcc_s_dw2-1.dll',
                                    'libstdc++-6.dll'])
    copy_all(opencv_lib, tpl_cv2, 'libopencv*')
    # Python bindings
    copy_all(py_dist_packages, tpl_cv2, ['cv2.so','cv2.pyd','libcv2*'])
    with open(tpl_cv2+'/__init__.py', 'w') as cv2_init:
        cv2_init.write(textwrap.dedent('''
        # autogenerated in build_tpl.py
        import os, sys
        from os.path import realpath, dirname
        tpl_cv2 = realpath(dirname(__file__))
        sys.path.insert(0, tpl_cv2)
        os.environ['PATH'] = tpl_cv2 + os.pathsep + os.environ['PATH']
        try:
            from cv2 import *
        except Exception as ex:                       
            print(repr(ex))
            print(os.environ['PATH'])
            print(sys.path)
            raise
        '''))

def localize_flann():
    print('____ Localizing flann ____')
    # Where to install
    # Where to install
    tpl_pyflann   = tpl_root+'/pyflann'
    ensure_path(tpl_pyflann) 
    if sys.platform == 'win32':
        # Libraries
        flann_lib   = 'C:/Program Files (x86)/flann/lib'
        copy_all(flann_lib,  tpl_pyflann, 'libflann*')
        # Better do the bin as well (like opencv)
        flann_bin   = 'C:/Program Files (x86)/flann/bin'
        copy_all(flann_lib,  tpl_pyflann, '*.dll')
        # Python bindings
        pyflann_dir = py_dist_packages+'/pyflann'
        copy_all(pyflann_dir,  tpl_pyflann, '*.py')
    else:
        # Libraries
        flann_lib   = install_prefix+'/lib'
        copy_all(flann_lib,  tpl_pyflann, 'libflann*')
        # Python bindings
        pyflann_dir = install_prefix+'/share/flann/python/pyflann'
        copy_all(pyflann_dir,  tpl_pyflann, '*.py')


exec_str_template = """
if 'localize_%s' in sys.argv or localize_all:
    localize_%s()
if 'build_%s' in sys.argv or build_all:
    build_%s()
if '%s' in sys.argv:
    build_%s()
    localize_%s()
"""
num_subs = exec_str_template.count('%s')

if __name__ == '__main__':
    localize_all = False
    build_all = False

    tpl_list = ['flann', 'opencv', 'hesaff']

    if 'localize_all' in sys.argv: 
        localize_all = True
    if 'build_all' in sys.argv: 
        build_all = True

    for tpl_name in tpl_list:
        exec_str = exec_str_template % tuple([tpl_name]*num_subs)
        exec(exec_str)
